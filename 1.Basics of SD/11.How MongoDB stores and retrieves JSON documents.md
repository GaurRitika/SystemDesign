##  **Phase 1: MongoDB Data Model**

MongoDB stores data as **BSON** — short for **Binary JSON**.
It’s basically JSON but with extra data types (like `Date`, `ObjectId`, `Binary`, etc.) and binary efficiency.

Example Document:

```js
{
  _id: ObjectId("673fe1abc92a"),
  user_id: 123,
  username: "rahul",
  caption: "Coding at night ",
  likes: 530,
  comments: [
    { user: "aisha", text: "awesome!" },
    { user: "dev", text: "" }
  ],
  created_at: ISODate("2025-10-21T10:00:00Z")
}
```

Each document is stored in a **collection** (like a table in SQL).
MongoDB internally stores collections in **data files** with indexes in separate **B-Tree structures**.

---

##  **Phase 2: How MongoDB Stores Data**

1. The database is divided into **collections**.
2. Each collection stores **BSON documents**.
3. The documents are grouped into **extents** → extents are chunks of contiguous memory on disk.
4. MongoDB maintains **pointers** between documents in each extent for quick traversal.

So conceptually:

```
Collection "posts"
   ├── Extent 1
   │     ├── Doc #1
   │     ├── Doc #2
   └── Extent 2
         ├── Doc #3
         └── Doc #4
```

MongoDB uses **memory-mapped files** — meaning part of the disk file is mapped into RAM, giving fast access.

---

##  **Phase 3: Index Structure**

Indexes in MongoDB work just like in relational databases — typically **B-Trees**.
When you create an index, MongoDB maintains a separate tree mapping key → document location.

Example:

```js
db.posts.createIndex({ user_id: 1 })
```

Internally, MongoDB creates a **B-Tree**:

```
        [100]------[200]------[300]
         /             |           \
   [Docs<100]    [Docs100-200]   [Docs>300]
```

Each leaf node contains:

```
user_id → pointer_to_document
```

When you query:

```js
db.posts.find({ user_id: 123 })
```

MongoDB does:

1. Traverse the **B-Tree** → find `user_id = 123`
2. Get **disk pointer** to the document
3. Fetch that document directly (no full collection scan)

 This reduces lookup from **O(N)** → **O(log N)**

---

##  **Phase 4: Query Execution Flow (Instagram Example)**

Let’s say Instagram’s backend runs:

```js
db.posts.find({ user_id: 123 }).sort({ created_at: -1 }).limit(10)
```

Here’s what happens internally 

### **Step 1: Query Parser**

* MongoDB parses the query and builds a **query plan**.
* Checks whether an index can help (for `user_id` or `created_at`).

### **Step 2: Query Planner**

* Chooses the best index (using stats and histograms).
* Generates an **execution plan** (like SQL EXPLAIN).

### **Step 3: Index Lookup**

* Traverses the **B-Tree index** on `user_id`.
* Retrieves pointers for all docs where `user_id = 123`.

### **Step 4: Fetch Documents**

* Fetches documents from the collection’s data extents via pointers.

### **Step 5: Sort / Filter**

* If an index also exists on `created_at`, sorting is done **within the index**.
* Otherwise, MongoDB sorts in-memory (slower).

### **Step 6: Limit and Return**

* Applies `LIMIT 10`.
* Converts BSON → JSON.
* Sends data over TCP to the client.

---

##  **Phase 5: Example — With and Without Index**

### Without Index

```
Collection: 10 million posts
Query: { user_id: 123 }

→ MongoDB scans all 10 million documents
→ Filters each one
→ O(N) = very slow
```

### With Index

```
Index: user_id
Query: { user_id: 123 }

→ B-Tree lookup → directly get relevant documents
→ O(log N)
→ Fetch & return instantly
```

---

##  **Phase 6: Write Path (Insert / Update)**

When inserting a new post:

```js
db.posts.insertOne({
  user_id: 123,
  caption: "hello world",
  likes: 0
})
```

Internally:

1. MongoDB stores the new BSON document in the collection file.
2. Updates the **index structure** — inserts new key (`user_id = 123`) into the B-Tree.
3. Acknowledges success **only after** writing to the **journal file** (for durability).

So writes take slightly longer if there are many indexes.

---

##  **Phase 7: Scaling MongoDB (Sharding)**

MongoDB scales horizontally via **sharding**.

Example:
You shard on `user_id`.

| Shard   | Range     | Stored Data     |
| ------- | --------- | --------------- |
| Shard 1 | 1–100K    | Users 1–100K    |
| Shard 2 | 100K–200K | Users 100K–200K |
| Shard 3 | 200K–300K | Users 200K–300K |

When you query:

```js
db.posts.find({ user_id: 123 })
```

→ The router knows user_id=123 belongs to Shard 1
→ It forwards the query only to that shard
→ Result is returned faster and load stays balanced

---

##  **Phase 8: Summary Table**

| Concept             | Description                                  |
| ------------------- | -------------------------------------------- |
| **Storage Engine**  | BSON documents stored in extents on disk     |
| **Indexes**         | B-Tree (key → doc pointer)                   |
| **Query Flow**      | Parse → Plan → Index Lookup → Fetch → Return |
| **Read Efficiency** | O(log N) with index, O(N) without            |
| **Write Cost**      | Slightly higher due to index updates         |
| **Scaling**         | Sharding (horizontal partitioning)           |
| **Durability**      | Journal file (write-ahead log)               |

---

##  **Phase 9: Instagram’s Real Usage**

Instagram-like architecture might do:

| Component     | DB Type                  | Example                  |
| ------------- | ------------------------ | ------------------------ |
| User Data     | SQL (Postgres)           | Consistency-critical     |
| Posts Feed    | MongoDB (Document Store) | Flexible schema          |
| Stories Cache | Redis                    | Key–Value                |
| Analytics     | Cassandra                | Time-series column store |
| Follows Graph | Neo4j                    | Graph DB                 |

MongoDB is perfect for the **posts** and **comments** subsystem since every post has different metadata and embedded objects.

---

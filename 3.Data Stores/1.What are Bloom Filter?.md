https://app.eraser.io/workspace/zHHKZyXfvi0etPfquBc9?origin=share
Imagine you‚Äôre building **Instagram‚Äôs username system**.

Every time a new user signs up, you need to check:

> ‚ÄúDoes this username already exist?‚Äù

You could:

* Query the database each time ‚Üí but that‚Äôs **slow**
* Store all usernames in memory ‚Üí but that‚Äôs **huge**

You only need to know **‚Äúprobably exists‚Äù** or **‚Äúdefinitely does not exist‚Äù** ‚Äî
you don‚Äôt need exact certainty every time.

This is where **Bloom Filters** come in. 

---

## üåº What is a Bloom Filter?

> **A Bloom filter is a space-efficient probabilistic data structure used to test whether an element is a member of a set.**

It can tell you:

*  ‚ÄúElement is *probably* in the set‚Äù
*  ‚ÄúElement is *definitely not* in the set‚Äù

So it may give **false positives**, but **never false negatives**.

---

##  Internal Working (Step by Step)

Let‚Äôs build intuition with an example.

###  Step 1: The Structure

* Bloom filter is just a **bit array** (say of size `m` bits, all 0 initially).
* It uses **k independent hash functions** that each map an input ‚Üí [0, m-1].

```
Bit array (initially)
[ 0 0 0 0 0 0 0 0 0 0 ]
```

---

### ü™Ñ Step 2: Inserting an Element

Suppose we insert `"alice"` into the filter.

We compute k hashes:

| Hash        | Result (position) |
| ----------- | ----------------- |
| h1("alice") | 2                 |
| h2("alice") | 5                 |
| h3("alice") | 9                 |

Now we set those bits to 1:

```
[ 0 0 1 0 0 1 0 0 0 1 ]
```

Now we insert `"bob"`:

| Hash      | Result |
| --------- | ------ |
| h1("bob") | 1      |
| h2("bob") | 5      |
| h3("bob") | 7      |

After insertion:

```
[ 0 1 1 0 0 1 0 1 0 1 ]
```

---

###  Step 3: Checking Membership

Now we check for `"alice"`:

* h1("alice") = 2 ‚Üí bit[2] = 1 
* h2("alice") = 5 ‚Üí bit[5] = 1 
* h3("alice") = 9 ‚Üí bit[9] = 1 

 All bits are 1 ‚Üí ‚Äú*Probably* present‚Äù.

Check `"charlie"`:

* h1("charlie") = 0 ‚Üí bit[0] = 0 
  ‚Üí ‚Äú*Definitely not present*‚Äù.

---

##  The Core Principle

> If any of the hash bits are 0 ‚Üí element is **definitely not present**
> If all hash bits are 1 ‚Üí element is **probably present** (false positive possible)

---

##  Space Efficiency

The bit array uses **very little space** ‚Äî much smaller than storing full strings or keys.

That‚Äôs why systems like **Cassandra**, **Bigtable**, and **HBase** use Bloom Filters before hitting disk ‚Äî to avoid unnecessary lookups.

---

##  Real-World Example: Cassandra

In Cassandra, Bloom filters are used on each **SSTable** (sorted string table) file.

When a read request comes:

1. Cassandra checks the Bloom filter for that key.
2. If Bloom filter says  ‚Äúdefinitely not present‚Äù ‚Üí skip reading that file.
3. If it says  ‚Äúmaybe present‚Äù ‚Üí check that SSTable.

This avoids expensive disk I/O in 99% of cases. ‚ö°

---

##  False Positives & Probability

Bloom filters can **never** give false negatives but can give **false positives**.
The probability of false positives depends on:

* m = size of bit array
* k = number of hash functions
* n = number of elements inserted

Choosing m and k properly minimizes the probability.

There‚Äôs even a formula:
[
P(\text{false positive}) = \left(1 - e^{-\frac{k n}{m}}\right)^k
]

---

##  Analogy

Imagine you have **3 doormen** guarding a club.
Each time a guest enters, all 3 mark something on their clipboard.
Later, if someone asks ‚Äúis this person inside?‚Äù, the doormen check their marks.

* If any doorman says ‚Äúno‚Äù, that person is definitely outside.
* If all say ‚Äúyes‚Äù, they *might* be inside ‚Äî but maybe it‚Äôs a false memory.

---

## Use Cases

| System                           | Use of Bloom Filter                                                  |
| -------------------------------- | -------------------------------------------------------------------- |
| **Cassandra / HBase / Bigtable** | Quickly check if key might exist before disk lookup                  |
| **Web browsers (Chrome)**        | Check if a URL is *probably* malicious before querying full database |
| **CDNs / Proxies**               | Check cache existence                                                |
| **Bitcoin / Ethereum**           | For lightweight clients to check transactions                        |
| **Spell checkers**               | To see if a word ‚Äúprobably‚Äù exists before dictionary lookup          |

---

##  Example in Pseudocode

```cpp
// Simplified Bloom Filter
class BloomFilter {
    vector<int> bits;
    int m, k;

public:
    BloomFilter(int size, int hashCount) {
        m = size;
        k = hashCount;
        bits = vector<int>(m, 0);
    }

    void insert(string key) {
        for (int i = 0; i < k; i++) {
            int pos = hash(key + to_string(i)) % m;
            bits[pos] = 1;
        }
    }

    bool mayContain(string key) {
        for (int i = 0; i < k; i++) {
            int pos = hash(key + to_string(i)) % m;
            if (bits[pos] == 0)
                return false; // definitely not present
        }
        return true; // probably present
    }
};
```




#  Step 1: What Is a Transaction?

A **transaction** is a logical unit of work that consists of one or more operations that must **succeed or fail together**.

👉 Example:

```sql
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

This ensures:

* If **both succeed → commit**.
* If **any fails → rollback**.

---

#  Step 2: The "I" in ACID

ACID = Atomicity, Consistency, Isolation, Durability

➡️ **Isolation** means:

> Transactions executing concurrently should **not interfere** with each other’s data in a way that produces incorrect results.

In simpler words:

> “Each transaction should behave as if it’s running alone — even if hundreds of others are happening simultaneously.”

---

#  Step 3: The Problem — Concurrent Transactions

Let’s say:

* T1 → reads account balance = ₹1000
* T2 → deposits ₹500 at the same time
* T1 → deducts ₹200

Depending on how the database **isolates** these transactions, T1 and T2 may:

* See each other’s changes,
* Overwrite each other,
* Or remain unaware.

Hence → different isolation levels exist.

---

#  Step 4: Anomalies That Can Occur

Before we define isolation levels, we must understand **what they prevent**.

| Phenomenon              | Description                                             | Example                                                                  |
| ----------------------- | ------------------------------------------------------- | ------------------------------------------------------------------------ |
| **Dirty Read**          | Reading data written by another uncommitted transaction | T1 updates balance but hasn’t committed yet; T2 reads it.                |
| **Non-repeatable Read** | Reading same row twice gives different results          | T1 reads balance ₹1000, T2 commits update ₹1500, T1 reads again → ₹1500. |
| **Phantom Read**        | A new row appears in a repeated query                   | T1 counts users = 5, T2 adds a new user, T1 counts again → 6.            |
| **Lost Update**         | Two transactions overwrite each other’s changes         | T1 and T2 both deduct ₹100, final balance reflects only one.             |

---

#  Step 5: SQL Transaction Isolation Levels

SQL defines **4 standard isolation levels**.
Each one offers stronger isolation — but slower performance.

Let’s go from weakest → strongest 👇

---

## 1️⃣ **READ UNCOMMITTED** (Lowest Isolation)

> Transactions can read **uncommitted (dirty)** data from others.

 Example:

* T1: `UPDATE users SET balance = 0;` (not committed)
* T2: `SELECT balance FROM users;` → sees 0 even though T1 hasn’t committed.

 Problems:

* Dirty reads
* Non-repeatable reads
* Phantom reads

 Fastest, but unsafe.

Used in: Rare cases like analytics where accuracy < speed.

---

## 2️⃣ **READ COMMITTED** (Most Common Default)

> Transaction can **only read committed data**.

 Example:

* T1’s updates are invisible until it commits.
* T2 always sees only committed values.

 Still possible:

* Non-repeatable reads (data can change between two reads)
* Phantom reads

 Prevents dirty reads
 Good balance between correctness and performance.

Used by:

* PostgreSQL (default)
* Oracle (default)

---

## 3️⃣ **REPEATABLE READ**

> Ensures that if a transaction reads a row once, all future reads of that row return the same data (until transaction ends).

 Example:

* T1 reads balance ₹1000.
* T2 updates to ₹1200 and commits.
* T1 reads again → still sees ₹1000 (repeatable).

⚠️ Phantom rows (new inserts that match WHERE clause) can still appear.

✅ Prevents:

* Dirty reads
* Non-repeatable reads

Used by:

* MySQL InnoDB (default)

---

## 4️⃣ **SERIALIZABLE** (Highest Isolation)

> Transactions behave as if they’re executed **one after another (serially)** — even though they run concurrently.

 Example:

* T1 and T2 both trying to withdraw money will be **ordered by the DB** so results are same as serial execution.

✅ Prevents all anomalies:

* Dirty read ❌
* Non-repeatable read ❌
* Phantom read ❌

❌ But very slow — locks or aborts many transactions.

Used in: Financial/banking systems where correctness > performance.
---
#  Step 8: Real-World Example — Bank Account Transfers

Two users transferring money at the same time:

| Isolation Level  | Possible Problem                      |
| ---------------- | ------------------------------------- |
| Read Uncommitted | See uncommitted balances              |
| Read Committed   | One might see outdated balance        |
| Repeatable Read  | Each sees consistent snapshot         |
| Serializable     | Fully correct — but slower throughput |

---
